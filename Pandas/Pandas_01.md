# 판다스 자료구조



### 판다스를 배우는 이유

​	빅데이터의 시대가 다가왔다. 인공지능과 빅데이터 기술이 놀라운 속도로 발전하며 삶의 패러다임을 바꾸고 있다. 엄청나게 빠른 속도로 쌓여가는 방대한 데이터와 그 데이터를 저장, 분석할 수 있는 컴퓨팅 파워의 결합이 data science라는 새로운 영역의 출현을 가능케 했다.

​	클라우드 컴퓨팅이 확산됨에 따라 비용은 더욱 저렴해지고, 제공하는 서비스도 다양해지는 추세다.

​	데이터 과학은 데이터를 연구하는 분야이고, 데이터 자체가 가장 중요한 자원이다. 실제로 데이터 분석 업무의 80~90%는 데이터를 수집하고 정리하는 일이 차지한다. 나머지 10~20%는 알고리즘을 선택하고, 모델링 결과를 분석하여 데이터로부터 유용한 정보를 뽑아내는 분석 프로세스의 몫이다.

​	판다스 라이브러리는 데이터를 수집하고 정리하는 데 최적화된 도구이다. 그리고 오픈소스라서 무료이다. 무엇보다 가장 배우기 쉬운 프로그래밍 언어인 파이썬을 기반으로 하기 때문에 전공자가 아닌 사람이더라도 쉽게 따라가며 배울 수 있다.



---



### Series

- 1차원 배열의 형태
- 인덱스(index)와 데이터 값(value)이 일대일 대응 구조 >> 파이썬 딕셔너리(dictionary)와 유사



#### 1) 딕셔너리 변환

```python
import pandas as pd

>>> dict_data = {'a':1,'b':2,'c':3}
>>> dict_data
{'a': 1, 'b': 2, 'c': 3}

>>> sr = pd.Series(dict_data)
>>> sr
'''
a    1
b    2
c    3
dtype: int64
'''
    
>>> print(type(sr))
<class 'pandas.core.series.Series'>
```

​	시리즈는 딕셔너리 구조와 비슷하기 때문에, 딕셔너리를 시리즈로 변환할 수 있다. 딕셔너리에서 key 값이 시리즈에서 index 값이다. 두 코드의 결과값을 비교해 보자.



#### 2) 리스트 변환

```python
>>> list_data = ['2019-01-02', 3.14, 'ABC', 100, True]
>>> list_data
['2019-01-02', 3.14, 'ABC', 100, True]

>>> sr = pd.Series(list_data)
>>> sr
'''
0    2019-01-02
1          3.14
2           ABC
3           100
4          True
dtype: object
'''

>>> sr.index
RangeIndex(start=0, stop=5, step=1)

>>> sr.values
array(['2019-01-02', 3.14, 'ABC', 100, True], dtype=object)

>>> sr[2]
'ABC'

>>> sr[0:2]
'''
0    2019-01-02
1          3.14
dtype: object
'''

>>> sr[[2, 4]]
'''
2     ABC
4    True
dtype: object
'''
```

​	파이썬 리스트(list) 역시 시리즈로 변환할 수 있다. 이때 모든 타입의 원소를 받을 수 있고, 따로 인덱스를 지정하지 않을 시, 디폴트로 정수형으로 설정된다. 그리고 리스트의 순서대로 입력된다.

​	인덱싱은 파이썬 리스트 인덱스와 동일하게 사용 가능하다. 인덱스가 정수형이면 숫자로 하면 되고, 인덱스가 이름(라벨)을 사용할 때는 따옴표를 사용해 이름을 입력하면 된다. 그리고 여러 개의 원소를 불러올 때, 연속적이라면 [0:2] 이런 식으로 입력하고, 연속적이지 않은 원소를 불러올 땐 [[2, 4]] 이런 식으로 괄호를 두 개 사용하면 된다.



#### 3) 튜플 변환

```python
tup_data = ('길동','2010-02-18','남',True)

>>> sr = pd.Series(tup_data, index=['이름','생년월일','성별','학생여부'])
>>> sr
'''
이름              길동
생년월일    2010-02-18
성별               남
학생여부          True
dtype: object
'''
    
>>> sr[0]
>>> sr['이름']
'길동'
```

​	튜플(tuple) 역시 시리즈 변환이 가능하고, 시리즈로 변환할 때 index를 설정해 줄 수도 있다.



---



### Dataframe

- 2차원 배열의 형태. 2차원 벡터 또는 행렬(matrix)
- 행과 열로 구성
- R의 데이터프레임에서 유래되었다고 알려짐
- 여러 개의 시리즈가 모인 구조 >> 데이터프레임의 열은 각각의 시리즈 객체이다.



#### 1) 딕셔너리 변환

```python
>>> dict_data = {'c0':[1,2,3], 'c1':[4,5,6], 'c2':[7,8,9], 'c3':[10,11,12], 'c4':[13,14,15]}
>>> dict_data
'''
{'c0': [1, 2, 3],
 'c1': [4, 5, 6],
 'c2': [7, 8, 9],
 'c3': [10, 11, 12],
 'c4': [13, 14, 15]}
 '''

df = pd.DataFrame(dict_data)
df
'''
   c0  c1  c2  c3  c4
0   1   4   7  10  13
1   2   5   8  11  14
2   3   6   9  12  15
'''

>>> print(type(df))
<class 'pandas.core.frame.DataFrame'>
```

​	딕셔너리 변수를 만들어서 데이터프레임으로 변환하는 작업이다. 이때 딕셔너리의 value는 리스트를 활용해 3개의 원소로 만들었으며 모든 원소의 개수는 일정하게 만들었다. 그리고 데이터프레임을 확인해 보면 인덱스는 디폴트인 정수형으로 입력되었고, 컬럼명은 딕셔너리의 key 값이 설정된 것을 확인할 수 있다.



#### 2) 인덱스, 컬럼명 사용자 직접 지정

```python
>>> df = pd.DataFrame([[15,'남','덕영중'], [17,'여','수리중']], index=['준서','예은'], columns=['나이','성별','학교'])
>>> df
'''
    나이 성별   학교
준서  15  남  덕영중
예은  17  여  수리중
'''

>>> df.index
Index(['준서', '예은'], dtype='object')

>>> df.columns
Index(['나이', '성별', '학교'], dtype='object')
```

​	데이터프레임을 만들 때 인덱스와 컬럼명은 사용자가 직접 설정할 수 있다. 여기서 주의할 것은 앞서 살펴본 딕셔너리는 리스트의 원소가 열이 되었는데, 여기서는 행으로 변환이 된다. 이 점을 기억하자.



#### 3) 인덱스, 컬럼명 변경

```python
>>> df.index = ['학생1','학생2']
>>> df.columns = ['연령','남녀','소속']
>>> df
'''
     연령 남녀   소속
학생1  15  남  덕영중
학생2  17  여  수리중
'''

df.rename(index={'학생1':'주혁','학생2':'수지'}, columns={'연령':'나이','남녀':'성별','소속':'학교'}, inplace=True)
'''
    나이 성별   학교
주혁  15  남  덕영중
수지  17  여  수리중
'''
```

​	위 코드처럼 행과 열의 이름을 변경할 수 있다. 첫 번째는 속성을 이용하여 변경한 방법이고, 두 번째는 rename() 메소드를 적용하여 변경한 방법이다. 이때 rename의 경우에는 원본 객체를 직접 수정하는 것이 아니기 때문에 inplace를 True로 해주어 저장해 주어야 한다.



#### 4) 삭제

```python
>>> exam_data = {'수학':[90,80,70], '영어':[98,89,95], '음악':[85,95,100], '체육':[100,90,90]}
>>> df = pd.DataFrame(exam_data, index=['서준','지수','민아'])
>>> df
'''
    수학  영어   음악   체육
서준  90  98   85  100
지수  80  89   95   90
민아  70  95  100   90
'''

>>> df.drop('서준', inplace=True)
'''
    수학  영어   음악  체육
지수  80  89   95  90
민아  70  95  100  90
'''

>>> df.drop('수학', axis=1)
'''
    영어   음악   체육
서준  98   85  100
지수  89   95   90
민아  95  100   90
'''

>>> df.drop(['서준','민아'])
'''
    수학  영어  음악  체육
지수  80  89  95  90
'''

>>> df.drop(['수학','음악'], axis=1, inplace=True)
'''
    영어   체육
서준  98  100
지수  89   90
민아  95   90
'''
```

​	행 또는 열을 삭제할 때는 drop() 함수를 사용한다. 여러 항목을 제거하고 싶을 땐 리스트를 함께 사용하고, axis를 통해 축을 지정한다. 디폴트는 axis = 0으로 행(가로)축을 의미한다. 그리고 drop 역시 원본 객체를 변경하지 않기 때문에 inplace를 통해 저장한다. 



#### 5) 행 선택

- loc : 인덱스 이름을 기준으로 선택
- iloc : 정수형 위치 인덱스를 사용하여 선택

```python
# loc
>>> df.loc['서준']
'''
수학     90
영어     98
음악     85
체육    100
Name: 서준, dtype: int64
'''

>>> df.loc[['서준','민아']]
'''
    수학  영어   음악   체육
서준  90  98   85  100
민아  70  95  100   90
'''

>>> df.loc['서준':'지수']
'''
    수학  영어  음악   체육
서준  90  98  85  100
지수  80  89  95   90
'''
```

​	loc는 인덱스 이름을 사용하여 값을 추출하며, '서준'만 추출했을 때는 시리즈 형태로 값을 반환한다. 그리고 연속적인 값을 추출할 때는 ':'를 활용하고, 비연속적인 값을 추출할 때는 [[]]를 사용해 인덱싱해주면 된다.



```python
# iloc
>>> df.iloc[0]
'''
수학     90
영어     98
음악     85
체육    100
Name: 서준, dtype: int64
'''

>>> df.iloc[[0,2]]
'''
    수학  영어   음악   체육
서준  90  98   85  100
민아  70  95  100   90
'''

>>> df.iloc[0:3]
'''
    수학  영어   음악   체육
서준  90  98   85  100
지수  80  89   95   90
민아  70  95  100   90
'''
```

​	iloc는 정수형 인덱스를 사용하며, 앞서 본 loc와 사용법은 똑같다.