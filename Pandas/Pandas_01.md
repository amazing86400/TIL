# 판다스 자료구조



### 판다스를 배우는 이유

​	빅데이터의 시대가 다가왔다. 인공지능과 빅데이터 기술이 놀라운 속도로 발전하며 삶의 패러다임을 바꾸고 있다. 엄청나게 빠른 속도로 쌓여가는 방대한 데이터와 그 데이터를 저장, 분석할 수 있는 컴퓨팅 파워의 결합이 data science라는 새로운 영역의 출현을 가능케 했다.

​	클라우드 컴퓨팅이 확산됨에 따라 비용은 더욱 저렴해지고, 제공하는 서비스도 다양해지는 추세다.

​	데이터 과학은 데이터를 연구하는 분야이고, 데이터 자체가 가장 중요한 자원이다. 실제로 데이터 분석 업무의 80~90%는 데이터를 수집하고 정리하는 일이 차지한다. 나머지 10~20%는 알고리즘을 선택하고, 모델링 결과를 분석하여 데이터로부터 유용한 정보를 뽑아내는 분석 프로세스의 몫이다.

​	판다스 라이브러리는 데이터를 수집하고 정리하는 데 최적화된 도구이다. 그리고 오픈소스라서 무료이다. 무엇보다 가장 배우기 쉬운 프로그래밍 언어인 파이썬을 기반으로 하기 때문에 전공자가 아닌 사람이더라도 쉽게 따라가며 배울 수 있다.



---



### Series

- 1차원 배열의 형태
- 인덱스(index)와 데이터 값(value)이 일대일 대응 구조 >> 파이썬 딕셔너리(dictionary)와 유사



#### 1) 딕셔너리 변환

```python
import pandas as pd

>>> dict_data = {'a':1,'b':2,'c':3}
>>> dict_data
{'a': 1, 'b': 2, 'c': 3}

>>> sr = pd.Series(dict_data)
>>> sr
'''
a    1
b    2
c    3
dtype: int64
'''
    
>>> print(type(sr))
<class 'pandas.core.series.Series'>
```

​	시리즈는 딕셔너리 구조와 비슷하기 때문에, 딕셔너리를 시리즈로 변환할 수 있다. 딕셔너리에서 key 값이 시리즈에서 index 값이다. 두 코드의 결과값을 비교해 보자.



#### 2) 리스트 변환

```python
>>> list_data = ['2019-01-02', 3.14, 'ABC', 100, True]
>>> list_data
['2019-01-02', 3.14, 'ABC', 100, True]

>>> sr = pd.Series(list_data)
>>> sr
'''
0    2019-01-02
1          3.14
2           ABC
3           100
4          True
dtype: object
'''

>>> sr.index
RangeIndex(start=0, stop=5, step=1)

>>> sr.values
array(['2019-01-02', 3.14, 'ABC', 100, True], dtype=object)

>>> sr[2]
'ABC'

>>> sr[0:2]
'''
0    2019-01-02
1          3.14
dtype: object
'''

>>> sr[[2, 4]]
'''
2     ABC
4    True
dtype: object
'''
```

​	파이썬 리스트(list) 역시 시리즈로 변환할 수 있다. 이때 모든 타입의 원소를 받을 수 있고, 따로 인덱스를 지정하지 않을 시, 디폴트로 정수형으로 설정된다. 그리고 리스트의 순서대로 입력된다.

​	인덱싱은 파이썬 리스트 인덱스와 동일하게 사용 가능하다. 인덱스가 정수형이면 숫자로 하면 되고, 인덱스가 이름(라벨)을 사용할 때는 따옴표를 사용해 이름을 입력하면 된다. 그리고 여러 개의 원소를 불러올 때, 연속적이라면 [0:2] 이런 식으로 입력하고, 연속적이지 않은 원소를 불러올 땐 [[2, 4]] 이런 식으로 괄호를 두 개 사용하면 된다.



#### 3) 튜플 변환

```python
tup_data = ('길동','2010-02-18','남',True)

>>> sr = pd.Series(tup_data, index=['이름','생년월일','성별','학생여부'])
>>> sr
'''
이름              길동
생년월일    2010-02-18
성별               남
학생여부          True
dtype: object
'''
    
>>> sr[0]
>>> sr['이름']
'길동'
```

​	튜플(tuple) 역시 시리즈 변환이 가능하고, 시리즈로 변환할 때 index를 설정해 줄 수도 있다.



---



### Dataframe

- 2차원 배열의 형태. 2차원 벡터 또는 행렬(matrix)
- 행과 열로 구성
- R의 데이터프레임에서 유래되었다고 알려짐
- 여러 개의 시리즈가 모인 구조 >> 데이터프레임의 열은 각각의 시리즈 객체이다.



#### 1) 딕셔너리 변환

```python
>>> dict_data = {'c0':[1,2,3], 'c1':[4,5,6], 'c2':[7,8,9], 'c3':[10,11,12], 'c4':[13,14,15]}
>>> dict_data
'''
{'c0': [1, 2, 3],
 'c1': [4, 5, 6],
 'c2': [7, 8, 9],
 'c3': [10, 11, 12],
 'c4': [13, 14, 15]}
 '''

df = pd.DataFrame(dict_data)
df
'''
   c0  c1  c2  c3  c4
0   1   4   7  10  13
1   2   5   8  11  14
2   3   6   9  12  15
'''

>>> print(type(df))
<class 'pandas.core.frame.DataFrame'>
```

​	딕셔너리 변수를 만들어서 데이터프레임으로 변환하는 작업이다. 이때 딕셔너리의 value는 리스트를 활용해 3개의 원소로 만들었으며 모든 원소의 개수는 일정하게 만들었다. 그리고 데이터프레임을 확인해 보면 인덱스는 디폴트인 정수형으로 입력되었고, 컬럼명은 딕셔너리의 key 값이 설정된 것을 확인할 수 있다.



#### 2) 인덱스, 컬럼명 사용자 직접 지정

```python
>>> df = pd.DataFrame([[15,'남','덕영중'], [17,'여','수리중']], index=['준서','예은'], columns=['나이','성별','학교'])
>>> df
'''
    나이 성별   학교
준서  15  남  덕영중
예은  17  여  수리중
'''

>>> df.index
Index(['준서', '예은'], dtype='object')

>>> df.columns
Index(['나이', '성별', '학교'], dtype='object')
```

​	데이터프레임을 만들 때 인덱스와 컬럼명은 사용자가 직접 설정할 수 있다. 여기서 주의할 것은 앞서 살펴본 딕셔너리는 리스트의 원소가 열이 되었는데, 여기서는 행으로 변환이 된다. 이 점을 기억하자.



#### 3) 인덱스, 컬럼명 변경

```python
>>> df.index = ['학생1','학생2']
>>> df.columns = ['연령','남녀','소속']
>>> df
'''
     연령 남녀   소속
학생1  15  남  덕영중
학생2  17  여  수리중
'''

df.rename(index={'학생1':'주혁','학생2':'수지'}, columns={'연령':'나이','남녀':'성별','소속':'학교'}, inplace=True)
'''
    나이 성별   학교
주혁  15  남  덕영중
수지  17  여  수리중
'''
```

​	위 코드처럼 행과 열의 이름을 변경할 수 있다. 첫 번째는 속성을 이용하여 변경한 방법이고, 두 번째는 rename() 메소드를 적용하여 변경한 방법이다. 이때 rename의 경우에는 원본 객체를 직접 수정하는 것이 아니기 때문에 inplace를 True로 해주어 저장해 주어야 한다.



#### 4) 삭제

```python
>>> exam_data = {'수학':[90,80,70], '영어':[98,89,95], '음악':[85,95,100], '체육':[100,90,90]}
>>> df = pd.DataFrame(exam_data, index=['서준','지수','민아'])
>>> df
'''
    수학  영어   음악   체육
서준  90  98   85  100
지수  80  89   95   90
민아  70  95  100   90
'''

>>> df.drop('서준', inplace=True)
'''
    수학  영어   음악  체육
지수  80  89   95  90
민아  70  95  100  90
'''

>>> df.drop('수학', axis=1)
'''
    영어   음악   체육
서준  98   85  100
지수  89   95   90
민아  95  100   90
'''

>>> df.drop(['서준','민아'])
'''
    수학  영어  음악  체육
지수  80  89  95  90
'''

>>> df.drop(['수학','음악'], axis=1, inplace=True)
'''
    영어   체육
서준  98  100
지수  89   90
민아  95   90
'''
```

​	행 또는 열을 삭제할 때는 drop() 함수를 사용한다. 여러 항목을 제거하고 싶을 땐 리스트를 함께 사용하고, axis를 통해 축을 지정한다. 디폴트는 axis = 0으로 행(가로) 축을 의미한다. 그리고 drop 역시 원본 객체를 변경하지 않기 때문에 inplace를 통해 저장한다. 



#### 5) 행 선택

- loc : 인덱스 이름을 기준으로 선택
- iloc : 정수형 위치 인덱스를 사용하여 선택

```python
# loc
>>> df.loc['서준']
'''
수학     90
영어     98
음악     85
체육    100
Name: 서준, dtype: int64
'''

>>> df.loc[['서준','민아']]
'''
    수학  영어   음악   체육
서준  90  98   85  100
민아  70  95  100   90
'''

>>> df.loc['서준':'지수']
'''
    수학  영어  음악   체육
서준  90  98  85  100
지수  80  89  95   90
'''
```

​	loc는 인덱스 이름을 사용하여 값을 추출하며, '서준'만 추출했을 때는 시리즈 형태로 값을 반환한다. 그리고 연속적인 값을 추출할 때는 ':'를 활용하고, 비연속적인 값을 추출할 때는 [[]]를 사용해 인덱싱해주면 된다.



```python
# iloc
>>> df.iloc[0]
'''
수학     90
영어     98
음악     85
체육    100
Name: 서준, dtype: int64
'''

>>> df.iloc[[0,2]]
'''
    수학  영어   음악   체육
서준  90  98   85  100
민아  70  95  100   90
'''

>>> df.iloc[0:3]
'''
    수학  영어   음악   체육
서준  90  98   85  100
지수  80  89   95   90
민아  70  95  100   90
'''

>>> df.iloc[::2]
>>> df.iloc[0:3:2]
'''
    수학  영어   음악   체육
서준  90  98   85  100
민아  70  95  100   90
'''

>>> df.iloc[::-1]
'''
    수학  영어   음악   체육
민아  70  95  100   90
지수  80  89   95   90
서준  90  98   85  100
'''
```

​	iloc는 정수형 인덱스를 사용하며, 앞서 본 loc와 사용법은 똑같다. iloc 인덱싱은 간격 설정도 할 수 있다. [::2]와 [0:3:2]는 전체 행에 대하여 간격을 2만큼 설정한 것이다. 그리고 간격을 -1로 해주면 역순으로 값을 반환한다.



#### 6) 열 선택

```python
>>> exam_data = {'이름':['서준','지수','민아'],'수학':[90,80,70],'영어':[98,78,95],'음악':[85,95,100],'체육':[100,90,90]}
>>> df = pd.DataFrame(exam_data)
>>> df
'''
   이름  수학  영어   음악   체육
0  서준  90  98   85  100
1  지수  80  78   95   90
2  민아  70  95  100   90
'''

>>> df['수학']
>>> df.수학
'''
0    90
1    80
2    70
Name: 수학, dtype: int64
'''

>>> df[['수학']]
'''
   수학
0  90
1  80
2  70
'''

>>> df[['수학','영어']]
'''
   수학  영어
0  90  98
1  80  78
2  70  95
'''
```

​	열을 선택할 때는 괄호([])와 점(.)을 사용하면 된다. 열 하나를 추출할 때는 괄호와 점 모두 사용할 수 있다. 이때는 시리즈 형태로 값을 반환한다. 열을 두 개 이상 추출할 때는 점은 사용하지 못하며, 2중 괄호를 사용한다. 이때 열 하나만을 입력하면 시리즈가 아닌 데이터프레임으로 값을 반환받을 수도 있다.



#### 7) 원소 선택

```python
>>> df
'''
   이름  수학  영어   음악   체육
0  서준  90  98   85  100
1  지수  80  78   95   90
2  민아  70  95  100   90
'''

>>> df.set_index('이름', inplace=True)
'''
    수학  영어   음악   체육
이름                  
서준  90  98   85  100
지수  80  78   95   90
민아  70  95  100   90
'''

>>> df.loc['서준','수학']
>>> df.iloc[0,0]
90

>>> df.loc['민아','음악']
>>> df.iloc[2,2]
100

>>> df.loc['서준',['수학','체육']]
>>> df.iloc[0, [0,3]]
'''
수학     90
체육    100
Name: 서준, dtype: int64
'''

>>> df.loc['서준':'민아', '음악']
>>> df.iloc[0:3, 2]
'''
이름
서준     85
지수     95
민아    100
Name: 음악, dtype: int64
'''

>>> df.loc[['서준','지수'], ['음악','체육']]
>>> df.iloc[[0,1], [2, 3]]
'''
    음악   체육
이름         
서준  85  100
지수  95   90
'''

>>> df.loc['서준':'민아','영어':'체육']
>>> df.iloc[0:3, 1:]
'''
    영어   음악   체육
이름              
서준  98   85  100
지수  78   95   90
민아  95  100   90
'''

df.loc[:,['음악','체육']]
df.iloc[[2,3], :]
```

​	원소를 찾는 방법이다. 원소를 찾을 때 역시 loc와 iloc를 사용해 주면 된다. 위에서는 행을 선택하는 법을 다뤘지만 괄호 안에 ','을 사용하여 구분해 준다면 행과 열을 지정하여 원소를 선택할 수 있다. loc[행 이름, 열 이름] 혹은 iloc[행 위치, 열 위치] 구조이다.

​	원소를 하나 찾을 때는 행과 열 하나씩만 입력해주면 된다. 두 개를 반환할 때는 2중 괄호를 사용하거나 ':'를 사용한 슬라이싱 방법을 사용한다. 행과 열 각각 2개 이상의 데이터를 추출하면 시리즈가 아닌 데이터프레임으로 값을 반환받는다. 그리고 ':'만 따로 사용해 주는 것은 전체를 의미한다.

​	set_index()는 열을 인덱스로 만드는 함수이다. 이 내용은 뒤에 더 자세히 다루겠다.

​	

#### 8) 열추가

```python
>>> df['국어'] = 80
>>> df
'''
    수학  영어   음악   체육  국어
이름                      
서준  90  98   85  100  80
지수  80  78   95   90  80
민아  70  95  100   90  80
'''

>>> df['국어'] = [89,92,100]
>>> df
'''
    수학  영어   음악   체육   국어
이름                       
서준  90  98   85  100   89
지수  80  78   95   90   92
민아  70  95  100   90  100
'''
```

​	열을 추가할 때는 인덱스를 활용하면 된다. 새로운 컬럼명을 인덱스로 나타내고 value를 설정하면 가장 마지막 열에 추가된다. value를 하나만 지정하면 값이 통일되어 나오고, 리스트를 활용해 따로 지정해 줄 수도 있다.



#### 9) 행추가

```python
>>> df.loc['주혁'] = 0
'''
    수학  영어   음악   체육   국어
이름                       
서준  90  98   85  100   89
지수  80  78   95   90   92
민아  70  95  100   90  100
주혁   0   0    0    0    0
'''

>>> df.loc['유진'] = [90,87,95,77,95]
'''
    수학  영어   음악   체육   국어
이름                       
서준  90  98   85  100   89
지수  80  78   95   90   92
민아  70  95  100   90  100
주혁   0   0    0    0    0
유진  90  87   95   77   95
'''

>>> df.loc['민주'] = df.loc['지수']
'''
    수학  영어   음악   체육   국어
이름                       
서준  90  98   85  100   89
지수  80  78   95   90   92
민아  70  95  100   90  100
주혁   0   0    0    0    0
유진  90  87   95   77   95
민주  80  78   95   90   92
'''
```

​	행을 추가할 때는 loc 인덱서를 사용하면 된다. 원리는 열 추가와 동일하다. 또한 행 벡터 자체가 배열이므로, 기존 행을 복사해서 새로운 행에 그대로 추가할 수도 있다. 기존 행 인덱스와 중복될 경우 새로운 행을 추가하지 않고 기존에 있던 행의 원소 값을 변경한다. 그리고 인덱스 순서 또한 상관없이 지정해도 무관하다.



#### 10) 원소 값 변경

```python
df.iloc[0][3] = 98
df.loc['서준']['체육'] = 98
df.loc['서준','체육'] = 98

df.loc['서준',['음악','체육']] = 80
df.iloc[0,[2,3]] = 80
df.iloc[0,[2,3]] = [99,100]
```

​	원소를 변경할 때도 loc와 iloc를 활용한다. 앞서 살펴본 원소를 선택하는 방법에서 값을 지정해 주는 원리이다. 즉, 원소 선택의 개념을 잘 이해한다면 값을 변경하는 것은 어렵지 않다.



#### 11) 행, 열 위치 바꾸기

```python
df.transpose()
df.T
```

​	행과 열을 서로 맞바꾸는 작업은 transpose() 혹은 T를 사용하면 된다.

