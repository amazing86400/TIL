# matrix



### 학습 목표

- matrix 구조를 이해하고 matrix의 기능과 인덱싱을 할 수 있다.



---



### matrix란

- 데이터의 형태가 2차원으로, 행(row)과 열(column)로 구성된다.
- 하나의 데이터 유형만 가능하고, 역행렬은 solve() 함수를 사용한다.
- matrix(data = NA, nrow = 1, ncol = 1, byrow = TRUE, dimnames = NULL) 구조이다.
- rbind() 함수는 vector를 행을 기준으로 추가한다.
- cbind() 함수는 vector를 열을 기준으로 추가한다.



---



### matrix 생성

```R
>>> m1 = matrix(1:8, nrow = 2)
     [,1] [,2] [,3] [,4]
[1,]    1    3    5    7
[2,]    2    4    6    8

>>> m2 = matrix(1:8, ncol = 4)
     [,1] [,2] [,3] [,4]
[1,]    1    3    5    7
[2,]    2    4    6    8

>>> m3 = matrix(1:8, nrow=2, byrow=TRUE)
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    5    6    7    8

>>> m4 = matrix(1:8)
     [,1]
[1,]    1
[2,]    2
[3,]    3
[4,]    4
[5,]    5
[6,]    6
[7,]    7
[8,]    8
```

​	matrix는 2차원 구조로 행과 열로 구성된다. 그래서 data 뒤에 행 또는 열을 지정할 수가 있다. 첫 번째 코드는 1부터 8까지의 숫자를 2행으로 만든다는 의미인데, 굳이 nrow와 ncol를 함께 쓰지 않는 이유는 하나만 써줘도 알아서 작업을 해주기 때문이다. 두 번째 코드는 열을 4로 지정한 것이다. 그리고 주의할 것이 byrow를 따로 지정해 주지 않아서 default 값인 FALSE로 반환돼 열을 우선으로 숫자가 채워진다.

 	byrow를 TRUE로 설정하면 세 번째 matrix처럼 행을 우선으로 값을 채워준다. 그리고 만약 data 외에 아무것도 입력하지 않았을 경우 열은 하나고 행이 data 수만큼 채워진다.



```python
>>> m1 = matrix(seq(1,10), nrow=5)
     [,1] [,2]
[1,]    1    6
[2,]    2    7
[3,]    3    8
[4,]    4    9
[5,]    5   10

>>> m2 = matrix(seq(1,6), ncol=3)
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

>>> m3 = matrix(seq(1,6), ncol=3, byrow=TRUE)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6

>>> m4 = rbind(seq(1,3), seq(4,6))
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6

>>> m5 = rbind(seq(1,3), seq(4,6), seq(7,10))
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    1
[2,]    4    5    6    4
[3,]    7    8    9   10

>>> m6 = rbind(seq(1,3), seq(4,6), seq(7,12))
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    2    3    1    2    3
[2,]    4    5    6    4    5    6
[3,]    7    8    9   10   11   12

>>> m7 = cbind(seq(1,3), seq(4,6))
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
```

​	seq() 함수를 사용해 matrix를 만들 수도 있다. m3까지는 위 코드와 유사하기 때문에 어렵지 않다.

​	rbind() 함수는 서로 다른 vector를 행을 기준으로 합치는 함수다. m4를 보면 1~3과 4~6까지의 두 벡터가 2행 3열로 합쳐진 것을 볼 수 있다. 그리고 만약 벡터의 수가 서로 다르다면 오류가 나오지만, m5처럼 첫 번째 수부터 하나씩 채워준다. 만약 수 차이가 배수 관계라면 m6처럼 반복해서 채우기도 한다. cbind()는 열을 기준으로 추가한다.



---



### 인덱싱

```R
>>> m = matrix(seq(1,12), nrow=4, ncol=3)
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    2    6   10
[3,]    3    7   11
[4,]    4    8   12

>>> m[2,3]
[1] 10

>>> m[2,]
[1]  2  6 10

>>> m[,-2]
     [,1] [,2]
[1,]    1    9
[2,]    2   10
[3,]    3   11
[4,]    4   12

>>> m[c(2,3), 2]
[1] 6 7

>>> m[c(TRUE, FALSE, FALSE, TRUE),]
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    4    8   12
```

​	인덱싱은 [행, 열]로 구분해서 추출하면 된다. 우선 [2,3]은 2행, 3열을 의미한다. 그래서 10을 반환했다. [2, ]는 2행과 열 전체를 의미한다. [, -2]는 행 전체와 2열 뺀 나머지 열을 가져온다. [c(2,3), 2]는 2, 3행과 2열을 가져온다. 마지막 코드는 TRUE의 값만 가져오기 때문에 1, 4행과 열 전체를 추출한다.